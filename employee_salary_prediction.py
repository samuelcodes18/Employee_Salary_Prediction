# -*- coding: utf-8 -*-
"""Employee Salary Prediction.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XXeh_6YQAAmpYt1TSgN6NPBZHhbWzpKq

# **Employee Salary Prediction**
###(Using ML Libraries)

---
"""

# Import necessary Py libraries
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import warnings
warnings.filterwarnings('ignore')

data=pd.read_csv(r"/content/Salary_List.csv")

data.shape

data.head()

data.tail()

data.info()

data.describe()

# Checking the null values in the data set
data.isna().sum()

print(data.workclass.value_counts())

data.workclass.replace({' ?':' Others'},inplace=True)
print(data['workclass'].value_counts())

print(data['occupation'].value_counts())

data.occupation.replace({' ?':' Others'},inplace=True)
print(data['occupation'].value_counts())

data=data[data['workclass']!=' Without-pay']
data=data[data['workclass']!=' Never-worked']
print(data['workclass'].value_counts())

print(data.relationship.value_counts())

print(data.sex.value_counts())

data.shape

#outlier detection
plt.boxplot(data['age'])
plt.show()

data=data[(data['age']<=75)&(data['age']>=17)]

plt.boxplot(data['education-num'])
plt.show()

data=data[(data['education-num']<=16)&(data['education-num']>=5)]

#redundant features removal
data=data.drop(columns=['education'])

data.shape

data

"""---

# **Data Visualization**
"""

data['sex'].value_counts().plot(kind='pie',
    explode=[0,0.2],
    labels=['Male','Female'],
    colors=['blue','gray'],
    autopct='%1.2f%%',
    shadow=True,
        )
plt.title("Visualize the Gender percentage in the data")
plt.show()

numerical=['education-num']
for i in numerical:
    plt.figure(figsize=(10,5))
    sns.countplot(data=data,x=i,hue='salary')
    plt.title([i])
    plt.xticks(rotation=90)
    plt.show()

numerical=['capital-gain']
for i in numerical:
    plt.figure(figsize=(10,5))
    sns.countplot(data=data,x=i,hue='salary')
    plt.title([i])
    plt.xticks(rotation=90)
    plt.show()

numerical=['hours-per-week']
for i in numerical:
    plt.figure(figsize=(10,5))
    sns.countplot(data=data,x=i,hue='salary')
    plt.title([i])
    plt.xticks(rotation=90)
    plt.show()

plt.figure(figsize=(10,6))
sns.countplot(data=data,x='age',hue='sex',palette='deep')
plt.xticks(rotation=90)
plt.show()

plt.figure(figsize=(10,5))
data['salary'].value_counts().sort_values(ascending=False).plot(kind='bar',
                                                               color=['#A9E2F3','#190710'])
plt.title("Visualize the Salary values in the data")
plt.xlabel("Salary")
plt.ylabel("Count of the values")
plt.show()

"""---

# **Label Encoding**
"""

from sklearn.preprocessing import LabelEncoder   #import libarary
encoder=LabelEncoder()                       #create object
data['workclass']=encoder.fit_transform(data['workclass']) #7 categories   0,1, 2, 3, 4, 5, 6,
data['marital-status']=encoder.fit_transform(data['marital-status'])   #3 categories 0, 1, 2
data['occupation']=encoder.fit_transform(data['occupation'])
data['relationship']=encoder.fit_transform(data['relationship'])      #5 categories  0, 1, 2, 3, 4
data['race']=encoder.fit_transform(data['race'])
data['sex']=encoder.fit_transform(data['sex'])    #2 catogories     0, 1
data['native-country']=encoder.fit_transform(data['native-country'])

data

# Split the data into independent and dependent variable
x=data.drop(columns=['salary'])
y=data['salary']
x

"""---

# **Machine Learning Modeling**
"""

# Install the all Required libraries for the machine Learning Modeling
from sklearn.pipeline import Pipeline
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score, classification_report
from sklearn.linear_model import LogisticRegression
from sklearn.ensemble import RandomForestClassifier, GradientBoostingClassifier
from sklearn.neighbors import KNeighborsClassifier
from sklearn.svm import SVC
from sklearn.preprocessing import StandardScaler, OneHotEncoder

X_train, X_test, y_train, y_test = train_test_split(x, y, test_size=0.2, random_state=42)

models = {
    "LogisticRegression": LogisticRegression(),
    "RandomForest": RandomForestClassifier(),
    "KNN": KNeighborsClassifier(),
    "SVM": SVC(),
    "GradientBoosting": GradientBoostingClassifier()
}

results = {}

for name, model in models.items():
    pipe = Pipeline([
        ('scaler', StandardScaler()),
        ('model', model)
    ])

    pipe.fit(X_train, y_train)
    y_pred = pipe.predict(X_test)
    acc = accuracy_score(y_test, y_pred)
    results[name] = acc
    print(f"{name} Accuracy: {acc:.4f}")
    print(classification_report(y_test, y_pred))

import matplotlib.pyplot as plt
plt.bar(results.keys(), results.values(), color='lightgreen')
plt.ylabel('Accuracy Score')
plt.title('Model Comparison')
plt.xticks(rotation=45)
plt.grid(True)
plt.show()

from sklearn.linear_model import LogisticRegression
from sklearn.ensemble import RandomForestClassifier, GradientBoostingClassifier
from sklearn.neighbors import KNeighborsClassifier
from sklearn.svm import SVC
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score
import joblib

# Train-test split
X_train, X_test, y_train, y_test = train_test_split(x, y, test_size=0.2, random_state=42)

# Define models
models = {
    "LogisticRegression": LogisticRegression(max_iter=1000),
    "RandomForest": RandomForestClassifier(),
    "KNN": KNeighborsClassifier(),
    "SVM": SVC(),
    "GradientBoosting": GradientBoostingClassifier()
}

results = {}

# Train and evaluate
for name, model in models.items():
    model.fit(X_train, y_train)
    preds = model.predict(X_test)
    acc = accuracy_score(y_test, preds)
    results[name] = acc
    print(f"{name}: {acc:.4f}")

# Get best model
best_model_name = max(results, key=results.get)
best_model = models[best_model_name]
print(f"\nâœ… Best model: {best_model_name} with accuracy {results[best_model_name]:.4f}")

# Save the best model
joblib.dump(best_model, "best_model.pkl")
print("âœ… Saved best model as best_model.pkl")

"""---

# **implementing using Streamlit**
"""

pip install joblib

!pip install streamlit pyngrok

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# import pandas as pd
# import numpy as np
# import streamlit as st
# import pickle
# from sklearn.preprocessing import StandardScaler
# import warnings
# warnings.filterwarnings('ignore')
# 
# # Updated title and subtitle
# st.title("ðŸ’¼Employee Salary Prediction [Using ML Libraries]")
# st.subheader("\nPlease enter the below information to predict the salary:")
# 
# # Load the best saved model
# import joblib
# model = joblib.load('best_model.pkl')
# 
# def main():
#     # Age slider
#     age = st.slider('Age', min_value=17, max_value=90, value=25)
# 
#     workclass = st.selectbox('Select Work Class', [' State-gov', ' Self-emp-not-inc', ' Private', ' Federal-gov',
#                                                     ' Local-gov', 'Others', ' Self-emp-inc', ' Without-pay', ' Never-worked'])
#     workclass_dict = {' State-gov': 0, ' Self-emp-not-inc': 1, ' Private': 2, ' Federal-gov': 3,
#                       ' Local-gov': 4, 'Others': 5, ' Self-emp-inc': 6, ' Without-pay': 7, ' Never-worked': 8}
#     workclass_1 = workclass_dict.get(workclass, 5)
# 
#     fnlwgt = st.number_input('Final Weight', min_value=12285, max_value=1484705, value=12285)
#     education_num = st.number_input('Education Number', min_value=1, max_value=16, value=1)
# 
#     marital_status = st.selectbox('Marital Status', [' Never-married', ' Married-civ-spouse', ' Divorced',
#                                                      ' Married-spouse-absent', ' Separated', ' Married-AF-spouse',
#                                                      ' Widowed'])
#     marital_dict = {' Never-married': 0, ' Married-civ-spouse': 1, ' Divorced': 2,
#                     ' Married-spouse-absent': 3, ' Separated': 4, ' Married-AF-spouse': 5, ' Widowed': 6}
#     marital_status_1 = marital_dict.get(marital_status, 0)
# 
#     occupation = st.selectbox('Occupation', [' Adm-clerical', ' Exec-managerial', ' Handlers-cleaners',
#                                              ' Prof-specialty', ' Other-service', ' Sales', ' Craft-repair',
#                                              ' Transport-moving', ' Farming-fishing', ' Machine-op-inspct',
#                                              ' Tech-support', ' Others', ' Protective-serv', ' Armed-Forces',
#                                              ' Priv-house-serv'])
#     occupation_dict = {' Adm-clerical': 0, ' Exec-managerial': 1, ' Handlers-cleaners': 2, ' Prof-specialty': 3,
#                        ' Other-service': 4, ' Sales': 5, ' Craft-repair': 6, ' Transport-moving': 7,
#                        ' Farming-fishing': 8, ' Machine-op-inspct': 9, ' Tech-support': 10, ' Others': 11,
#                        ' Protective-serv': 12, ' Armed-Forces': 13, ' Priv-house-serv': 14}
#     occupation_1 = occupation_dict.get(occupation, 11)
# 
#     relationship = st.selectbox('Relationship', [' Not-in-family', ' Husband', ' Wife', ' Own-child', ' Unmarried', ' Other-relative'])
#     relationship_dict = {' Not-in-family': 0, ' Husband': 1, ' Wife': 2, ' Own-child': 3, ' Unmarried': 4, ' Other-relative': 5}
#     relationship_1 = relationship_dict.get(relationship, 0)
# 
#     race = st.selectbox('Race', [' White', ' Black', ' Asian-Pac-Islander', ' Amer-Indian-Eskimo', ' Other'])
#     race_dict = {' White': 0, ' Black': 1, ' Asian-Pac-Islander': 2, ' Amer-Indian-Eskimo': 3, ' Other': 4}
#     race_1 = race_dict.get(race, 0)
# 
#     sex = st.selectbox('Sex', [' Male', ' Female'])
#     sex_1 = 0 if sex == ' Male' else 1
# 
#     capital_gain = st.number_input('Capital Gain', min_value=0, max_value=99999, value=0)
#     capital_loss = st.number_input('Capital Loss', min_value=0, max_value=4356, value=0)
#     hours_per_week = st.number_input('Hours Per Week', min_value=1, max_value=99, value=1)
# 
#     native_country = st.selectbox('Native Country', [' United-States', ' Cuba', ' Jamaica', ' India', ' Others', ' Mexico',
#                                                      ' South', ' Puerto-Rico', ' Honduras', ' England', ' Canada',
#                                                      ' Germany', ' Iran', ' Philippines', ' Italy', ' Poland',
#                                                      ' Columbia', ' Cambodia', ' Thailand', ' Ecuador', ' Laos',
#                                                      ' Taiwan', ' Haiti', ' Portugal', ' Dominican-Republic',
#                                                      ' El-Salvador', ' France', ' Guatemala', ' China', ' Japan',
#                                                      ' Yugoslavia', ' Peru', ' Outlying-US(Guam-USVI-etc)', ' Scotland',
#                                                      ' Trinadad&Tobago', ' Greece', ' Nicaragua', ' Vietnam', ' Hong',
#                                                      ' Ireland', ' Hungary', ' Holand-Netherlands'])
#     country_dict = {val: idx for idx, val in enumerate([' United-States', ' Cuba', ' Jamaica', ' India', ' Others', ' Mexico',
#                                                         ' South', ' Puerto-Rico', ' Honduras', ' England', ' Canada',
#                                                         ' Germany', ' Iran', ' Philippines', ' Italy', ' Poland',
#                                                         ' Columbia', ' Cambodia', ' Thailand', ' Ecuador', ' Laos',
#                                                         ' Taiwan', ' Haiti', ' Portugal', ' Dominican-Republic',
#                                                         ' El-Salvador', ' France', ' Guatemala', ' China', ' Japan',
#                                                         ' Yugoslavia', ' Peru', ' Outlying-US(Guam-USVI-etc)', ' Scotland',
#                                                         ' Trinadad&Tobago', ' Greece', ' Nicaragua', ' Vietnam', ' Hong',
#                                                         ' Ireland', ' Hungary', ' Holand-Netherlands'])}
#     native_country_1 = country_dict.get(native_country, 4)
# 
#     if st.button("Predict Salary Range"):
#         data = [age, workclass_1, fnlwgt, education_num, marital_status_1,
#                 occupation_1, relationship_1, race_1, sex_1, capital_gain, capital_loss,
#                 hours_per_week, native_country_1]
# 
#         # Apply scaling
#         scaler = StandardScaler()
#         scaled_data = scaler.fit_transform([data])
# 
#         result = model.predict(scaled_data)
#         if result == 0:
#             st.success("The salary is likely **less than 50K**.")
#         else:
#             st.success("The salary is likely **more than 50K**.")
# 
#         # Divider line after prediction
#         st.markdown("<hr>", unsafe_allow_html=True)
# 
# if __name__ == "__main__":
#     main()
#

!ngrok authtoken 30Be239F5se1aXEJa9rMfQ0z8Ic_54oVZv9bj3eqB96eaQK4Y

import os
import threading

def run_streamlit():
  os.system('streamlit run app.py --server.port 8502')

thread= threading.Thread(target=run_streamlit)
thread.start()

from pyngrok import ngrok
import time

# Kill existing ngrok tunnels
ngrok.kill()

time.sleep(5)

public_url= ngrok.connect(8502)
print("Streamlit app is live here: ", public_url)

"""

---



---

"""

